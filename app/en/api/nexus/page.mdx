---
title: nexus
description: Primary server-side data fetch function with hydration, delegation, retry/timeout, and interceptors.
---

# nexus

Import:

```ts path=null start=null
import { nexus, createNexusDefinition, NexusProvider } from "next-nexus";
```

## Signature

```ts path=null start=null
nexus<T>(definition: NexusDefinition<T>): Promise<NexusResponse<T>>
```

## Definition Options

- method: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE'
- endpoint: string (e.g. '/products')
- baseURL?: string (prepends endpoint)
- headers?: HeadersInit (merged)
- server?: `{ cache?: RequestCache; revalidate?: number; tags?: string[] }`
- client?: `{ revalidate?: number; tags?: string[]; cachedHeaders?: string[] }`
- timeout?: number (seconds)
- retry?: `{ count: number; delay?: number }`
- interceptors?: string[] (names of globally registered interceptors)

### Defaults
- Cache: if `server.cache` is omitted, nextâ€‘nexus defaults to `no-store` (Next.js 14 default is `force-cache`, 15+ is `no-store`). Set `server.cache: 'force-cache'` explicitly only where static caching/ISR is desired.

## Behavior

1. Request/Response Interceptors
   - Interceptors registered by name run in order on the server and/or client depending on their logic.
2. Retry & Timeout
   - Uses abortable timeouts and retries on timeout/server/ratelimited errors.
3. Hydration (Server, GET + client options)
   - Response data, tags, TTL, and selected headers are collected per-request.
   - Injected into HTML (`window.__NEXUS_PAYLOAD__`) and restored on the client.
4. ETag-aware TTL Extension
   - If client cache is stale and server ETag equals the client's ETag, the server marks the key as not-modified and the client extends TTL without re-downloading.
5. Rendering Delegation (with `<NexusSuspense>`)
   - If the client has a fresh cache entry for the matching GET definition and delegation is enabled, the server can skip rendering that subtree.
6. Next.js Cache Integration
   - `server.revalidate/tags` map to Next's `next:{ revalidate, tags }` and `cache` options.

## Error Handling

- Errors are `NexusError` when originated from the library. Use `isNexusError` to detect.

```ts path=null start=null
import { isNexusError } from "next-nexus/errors";

try {
  const res = await nexus(productDefinition.list);
} catch (e) {
  if (isNexusError(e)) {
    // e.code, e.response?.status, e.message
  }
}
```

## Examples

### Basic GET (factory usage)

```ts path=null start=null
import { createNexusDefinition } from 'next-nexus'

export interface Product {
  id: string
  name: string
}

export const createApiDefinition = createNexusDefinition({
  baseURL: 'https://api.example.com',
  retry: { count: 1, delay: 1 },
  timeout: 5,
})

export const productDefinition = {
  list: createApiDefinition<Product[]>({
    method: 'GET',
    endpoint: '/products',
    server: { tags: ['products'], revalidate: 1800 },
    client: { tags: ['products'], revalidate: 300, cachedHeaders: ['x-total-count'] },
  }),
}
```

### POST (factory usage)

```ts path=null start=null
const like = (id: string) =>
  createApiDefinition<{ success: boolean }>({
    method: 'POST',
    endpoint: `/products/${id}/like`,
  })
```

### With Interceptors

```ts path=null start=null
import { interceptors } from "next-nexus";

interceptors.request.use("auth", async (config) => {
  const headers = new Headers(config.headers);
  headers.set("authorization", "Bearer <token>");
  return { ...config, headers };
});

const protectedList = createNexusDefinition<{ items: unknown[] }>({
  method: "GET",
  endpoint: "/api/protected",
  interceptors: ["auth"],
});
```
