---
title: Cross‑cutting Concerns
description: Interceptors, error model, cached response headers, and debugging in one page.
---

# Cross‑cutting Concerns

Non-functional essentials that apply across reads and writes.

## Interceptors
- Add request/response/error interceptors once to apply to all nexus calls.
- Centralize auth headers, telemetry, or response shaping.

See: [Interceptors](/en/api/interceptors)

## Error model
Use `isNexusError` to reliably branch.
```ts path=null start=null
import { isNexusError } from 'next-nexus/errors'

try {
  await nexus(def)
} catch (e) {
  if (isNexusError(e)) {
    console.error(e.code, e.response?.status)
  }
}
```
See: [Error Handling](/en/api/errors)

## Cached response headers
- When defined by your server, selected response headers are cached with the entry and accessible on the client.
- Typical use cases: pagination totals (e.g., `x-total-count`), rate‑limit info.

See details and examples: [Definitions](/en/api/definitions)

## Debugging
- Enable dev logs with `NEXT_PUBLIC_NEXUS_DEBUG=true`.
- Logs include request/cache events like START/SUCCESS/ERROR/TIMEOUT, HIT/MISS, SKIP/MATCH, DELEGATE, SET/UPDATE/DELETE.

See: [/en/debugging](/en/debugging)

