---
title: 라이프사이클
description: 서버 페치부터 하이드레이션, 클라이언트 소비, 캐시/재검증까지 next‑nexus의 전체 흐름 2분 요약.
---

# 라이프사이클

next‑nexus가 어떻게 동작하는지 한눈에 이해하세요.

> 전제: Definition은 팩토리 기반만 사용하고, 앱은 반드시 NexusProvider로 감쌉니다. 참고: /ko/api/definitions, /ko/api/nexus-provider

## 한눈에 보기
1) 팩토리 함수로 엔드포인트 Definition 작성(기본 키는 Definition에서 파생).
2) 서버(RSC)에서 필요한 곳에서 `nexus(...)` 호출 → 응답 헤더/페이로드 수집.
3) 하이드레이션: `NexusProvider`가 최소 엔트리만 직렬화해 클라이언트로 전달.
4) 클라이언트 마운트 시 `NexusProvider`가 복원.
5) 읽기: 서버는 `nexus(...)`, 클라이언트는 `useNexusQuery`.
6) 쓰기: `useNexusMutation`/`useNexusAction`/`useNexusFormAction` 후 태그 재검증.
7) Cache, `revalidate`, tags는 Next.js 규칙과 1:1 매핑.
8) 오류는 `NexusError` 객체로 표준화되므로, `isNexusError` 타입 가드로 안전하게 처리할 수 있습니다.
9) 개발 모드에서 디버깅 로그로 요청/캐시 이벤트를 확인.

## 다이어그램
```text path=null start=null
Route/navigation
   ↓
Server RSC render ──▶ nexus(def, opts) ──▶ collect {data, etag, headers}
   ↓                                     \
Hydration payload ◀─────────────────────── restore on client
   ↓
Client render ──▶ useNexusQuery(...) ──▶ cache read/write, revalidate/tag
   ↓
Mutations/Actions ──▶ revalidate tags ──▶ re-fetch where subscribed
```

## 실행 위치
- 서버: 인바운드 헤더 읽기, RSC에서 `nexus(...)` 수행, 하이드레이션 엔트리 수집.
- 클라이언트: 하이드레이션 복원, 훅 실행, 필요 시 캐시된 응답 헤더 접근.

## 다음 단계
- 데이터 읽기 → [/ko/core-concepts/reading-data](/ko/core-concepts/reading-data)
- 데이터 쓰기 → [/ko/core-concepts/writing-data](/ko/core-concepts/writing-data)

더 알아보기: 자동 하이드레이션, RSC 요청 가로채기, 캐시 키/태그/TTL, ETag 로직, 인터셉터.

